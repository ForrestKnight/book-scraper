"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreloadScriptStorage = void 0;
/*
 * Copyright 2023 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uuid_1 = require("uuid");
/**
 * Container class for preload scripts.
 *
 * BiDi IDs are generated by the server and are unique within the context.
 *
 * CDP preload script IDs are generated by the client and are unique
 * within the session.
 *
 * The mapping between BiDi and CDP preload script IDs is 1:many.
 * BiDi IDs are needed by the mapper to keep track of potential multiple CDP IDs
 * in the client.
 *
 * This class does not concern itself with the validity of the IDs.
 */
class PreloadScriptStorage {
    /** Tracks all BiDi preload scripts.  */
    #scripts = new Set();
    /** Finds all entries that match the given filter. */
    findPreloadScripts(filter) {
        if (!filter) {
            return [...this.#scripts];
        }
        return [...this.#scripts].filter((script) => {
            if (filter?.id !== undefined && filter?.id !== script.id) {
                return false;
            }
            if (filter?.contextId !== undefined &&
                filter?.contextId !== script.contextId) {
                return false;
            }
            if (filter?.contextIds !== undefined &&
                !filter?.contextIds.includes(script.contextId)) {
                return false;
            }
            return true;
        });
    }
    /**
     * Keeps track of the given CDP preload scripts associated with the given
     * browsing context ID.
     *
     * @param contextId Browsing context ID, or null for global context.
     * @param cdpPreloadScripts CDP preload scripts.
     * @param functionDeclaration The script itself, in a format expected by the spec
     *   i.e. a function.
     */
    addPreloadScripts(contextId, cdpPreloadScripts, functionDeclaration, sandbox) {
        // Generate a random ID.
        const bidiId = (0, uuid_1.v4)();
        const preloadScript = {
            id: bidiId,
            contextId,
            cdpPreloadScripts,
            functionDeclaration,
            sandbox,
        };
        this.#scripts.add(preloadScript);
        return preloadScript;
    }
    /**
     * Keeps track of the given CDP preload script in the given BiDi preload
     * script.
     */
    appendCdpPreloadScript(script, cdpPreloadScript) {
        script.cdpPreloadScripts.push(cdpPreloadScript);
    }
    /** Deletes all BiDi preload script entries that match the given filter. */
    removeBiDiPreloadScripts(filter) {
        for (const preloadScript of this.findPreloadScripts(filter)) {
            this.#scripts.delete(preloadScript);
        }
    }
    /** Deletes all CDP preload script entries that match the given filter. */
    removeCdpPreloadScripts(filter) {
        for (const preloadScript of this.#scripts) {
            preloadScript.cdpPreloadScripts = preloadScript.cdpPreloadScripts.filter((cdpPreloadScript) => {
                if (filter?.targetId !== undefined &&
                    filter?.targetId !== cdpPreloadScript.target.targetId) {
                    return true;
                }
                if (filter?.sessionId !== undefined &&
                    filter?.sessionId !== cdpPreloadScript.target.cdpSessionId) {
                    return true;
                }
                return false;
            });
        }
    }
}
exports.PreloadScriptStorage = PreloadScriptStorage;
//# sourceMappingURL=PreloadScriptStorage.js.map