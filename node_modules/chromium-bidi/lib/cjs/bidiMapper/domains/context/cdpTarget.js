"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdpTarget = void 0;
const logManager_js_1 = require("../log/logManager.js");
const protocol_js_1 = require("../../../protocol/protocol.js");
const deferred_js_1 = require("../../../utils/deferred.js");
const networkProcessor_js_1 = require("../network/networkProcessor.js");
class CdpTarget {
    #targetId;
    #parentTargetId;
    #cdpClient;
    #cdpSessionId;
    #eventManager;
    #preloadScriptStorage;
    #targetUnblocked;
    #networkDomainActivated;
    static create(targetId, parentTargetId, cdpClient, cdpSessionId, realmStorage, eventManager, preloadScriptStorage) {
        const cdpTarget = new CdpTarget(targetId, parentTargetId, cdpClient, cdpSessionId, eventManager, preloadScriptStorage);
        logManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager);
        cdpTarget.#setEventListeners();
        // No need to await.
        // Deferred will be resolved when the target is unblocked.
        void cdpTarget.#unblock();
        return cdpTarget;
    }
    constructor(targetId, parentTargetId, cdpClient, cdpSessionId, eventManager, preloadScriptStorage) {
        this.#targetId = targetId;
        this.#parentTargetId = parentTargetId;
        this.#cdpClient = cdpClient;
        this.#cdpSessionId = cdpSessionId;
        this.#eventManager = eventManager;
        this.#preloadScriptStorage = preloadScriptStorage;
        this.#networkDomainActivated = false;
        this.#targetUnblocked = new deferred_js_1.Deferred();
    }
    /** Returns a promise that resolves when the target is unblocked. */
    get targetUnblocked() {
        return this.#targetUnblocked;
    }
    get targetId() {
        return this.#targetId;
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    /**
     * Needed for CDP escape path.
     */
    get cdpSessionId() {
        return this.#cdpSessionId;
    }
    /**
     * Enables all the required CDP domains and unblocks the target.
     */
    async #unblock() {
        try {
            // Enable Network domain, if it is enabled globally.
            // TODO: enable Network domain for OOPiF targets.
            if (this.#eventManager.isNetworkDomainEnabled) {
                await this.enableNetworkDomain();
            }
            await this.#cdpClient.sendCommand('Runtime.enable');
            await this.#cdpClient.sendCommand('Page.enable');
            await this.#cdpClient.sendCommand('Page.setLifecycleEventsEnabled', {
                enabled: true,
            });
            await this.#cdpClient.sendCommand('Target.setAutoAttach', {
                autoAttach: true,
                waitForDebuggerOnStart: true,
                flatten: true,
            });
            await this.loadPreloadScripts();
            await this.#cdpClient.sendCommand('Runtime.runIfWaitingForDebugger');
        }
        catch (error) {
            // The target might have been closed before the initialization finished.
            if (!error.message.includes('Target closed')) {
                throw error;
            }
        }
        this.#targetUnblocked.resolve();
    }
    /**
     * Enables the Network domain (creates NetworkProcessor on the target's cdp
     * client) if it is not enabled yet.
     */
    async enableNetworkDomain() {
        if (!this.#networkDomainActivated) {
            this.#networkDomainActivated = true;
            await networkProcessor_js_1.NetworkProcessor.create(this.cdpClient, this.#eventManager);
        }
    }
    #setEventListeners() {
        this.#cdpClient.on('*', (cdpMethod, params) => {
            this.#eventManager.registerEvent({
                method: protocol_js_1.CDP.EventNames.EventReceivedEvent,
                params: {
                    cdpMethod: cdpMethod,
                    cdpParams: params ?? {},
                    cdpSession: this.#cdpSessionId,
                },
            }, null);
        });
    }
    /** Loads all top-level and parent preload scripts. */
    async loadPreloadScripts() {
        for (const script of this.#preloadScriptStorage.findPreloadScripts({
            contextIds: [null, this.#parentTargetId],
        })) {
            const functionDeclaration = script.functionDeclaration;
            const sandbox = script.sandbox;
            // The spec provides a function, and CDP expects an evaluation.
            const cdpPreloadScriptId = await this.addPreloadScript(`(${functionDeclaration})();`, sandbox);
            this.#preloadScriptStorage.appendCdpPreloadScript(script, {
                target: this,
                preloadScriptId: cdpPreloadScriptId,
            });
        }
    }
    /**
     * Issues `Page.addScriptToEvaluateOnNewDocument` CDP command with the given
     * script source in evaluated form and world name / sandbox.
     *
     * @return The CDP preload script ID.
     */
    async addPreloadScript(scriptSource, sandbox) {
        const result = await this.cdpClient.sendCommand('Page.addScriptToEvaluateOnNewDocument', {
            source: scriptSource,
            worldName: sandbox,
        });
        return result.identifier;
    }
    /**
     * Issues `Page.removeScriptToEvaluateOnNewDocument` CDP command with the
     * given CDP preload script ID.
     */
    async removePreloadScript(cdpPreloadScriptId) {
        await this.cdpClient.sendCommand('Page.removeScriptToEvaluateOnNewDocument', {
            identifier: cdpPreloadScriptId,
        });
    }
}
exports.CdpTarget = CdpTarget;
//# sourceMappingURL=cdpTarget.js.map